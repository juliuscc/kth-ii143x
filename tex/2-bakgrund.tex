\chapter{JSON och JSON Scheman}
\label{sec:teori}
Det här kapitlet beskriver vad JSON och JSON Scheman är, samt hur de används. Kapitel \ref{sec:teori:json} beskriver vad JSON är. Kapitel \ref{sec:teori:json-web} beskriver hur JSON används för kommunikation mellan webbtjänster. Kapitel \ref{sec:teori:schema} beskriver JSON Scheman, vad de är och hur de är specificerade. Kapitel \ref{sec:teori:schema-användningsområden} diskuterar användningsområden av JSON Schema samt listar kända implementationer.

\section{JSON}
\label{sec:teori:json}
JSON erbjuder stöd för några enkla datatyper: textsträngar,  siffror, tomt värde samt booleska värden, som presenteras i figur \ref{tab:json-primitives}. JSON erbjuder dessutom stöd för två komplexa datatyper vilket är vektorer \textit{(array)}, en ordnad lista av JSON-värden, samt objekt \textit{(object)}, vilket är en oordnad mängd av namn-värde-par \textit{(properties)}. Exempel på de två komplexa datatyperna visas i figur \ref{fig:json-komplex-example}. Resten av rapporten kommer utbytbart använda JSON-värde, JSON-data, JSON-fil och JSON-dokument för att förklara en av de sex datatyperna som kan representeras med JSON.

\begin{table}
	\centering
	\caption{De primitiva datatyperna i JSON}
	\label{tab:json-primitives}
	\begin{tabular}{ | l | l | p{2.2cm} | }
		\hline
		Datatyp & Namn i JSON och JavaScript & Exempel \\
		\hline
		Textsträng & String & \mintinline{json}{"hej värld"} \\
		\hline
		Siffra & Number & \mintinline{json}{4} \\
		\hline
		Tomt värde & Null & \mintinline{json}{null} \\
		\hline
		Booleskt värde & Boolean & \mintinline{json}{false} \\
		\hline
	\end{tabular}
\end{table}

\begin{figure}
	\begin{subfigure}[t]{0.47\textwidth}
		\begin{minted}[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{json}
[
	"hej värld",
	4,
	null,
	false
]
		\end{minted}
		\vspace{-1.2em}
		\caption{Exempel på JSON-array}
		\label{fig:json-array-example}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{0.47\textwidth}
		\begin{minted}[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{json}
{
	"firstName": "Erik",
	"lastName": "Andersson",
	"age": 30,
	"human": true
}
		\end{minted}
		\vspace{-1.2em}
		\caption{Exempel på JSON-object}
		\label{fig:json-object-example}
	\end{subfigure}
	\caption{De komplexa datatyperna i JSON}
	\label{fig:json-komplex-example}
\end{figure}

\noindent
Med hjälp av att rekursivt använda \textit{array} eller \textit{object} går det att representera komplexa datastrukturer med hjälp av JSON. Det finns inga begränsningar i hur komplext datastrukturer kan representeras.

\section{JSON i webbkommunikation}
\label{sec:teori:json-web}
På grund av att JSON är kompakt, enkelt läsbart och har brett stöd hos många språk och implementationer, har JSON blivit väldigt utbrett bland webbtjänster. Figur \ref{fig:json-exchange-example} visar ett exempel på en hypotetiskt transaktion av data på webben. En hypotetisk förfrågan till en webbtjänst skulle kunna se ut som i Figur \ref{fig:json-request-example}, där en klient förfrågar om de nuvarande väderförhållandena i Stockholm i Sverige. Svaret från webbservern skulle kunna se ut som i Figur \ref{fig:json-response-example} där webbservern svarar att temperaturen är minus tre grader Celsius och att det snöar. Exemplet visar hur simpelt JSON som dataformat är att förstå, vilket delvis skulle kunna vara en förklaring för populariteten.

\begin{figure}
	\begin{subfigure}[t]{0.47\textwidth}
		\begin{minted}[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{json}
{
	"country": "Sweden",
	"city": "Stockholm"
}
		\end{minted}
		\vspace{-1.2em}
		\caption{Exempel på förfrågan till webbserver}
		\label{fig:json-request-example}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{0.47\textwidth}
		\begin{minted}[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{json}
{
	"timestamp": "06/01/2018 10:45:08",
	"country": "Sweden",
	"city": "Stockholm",
	"weather": "Snowing",
	"temperature": -3
}
		\end{minted}
		\vspace{-1.2em}
		\caption{Exempel på svar på förfrågan från webbserver}
		\label{fig:json-response-example}
	\end{subfigure}
	\caption{Exempel på datatransaktion mellan webbklient och webbserver}
	\label{fig:json-exchange-example}
\end{figure}

\section{JSON Schema}
\label{sec:teori:schema}
JSON Schema är ett ramverk för att förklara hur JSON-värden kan se ut. JSON Schema specificerar regler som kan användas för att antingen bestämma om befintliga JSON värden är giltiga, eller för att i förväg beskriva hur giltiga värden får se ut. Objektet i figur \ref{fig:json-object-example} skulle kunna valideras enligt JSON Schemat i figur \ref{fig:json-schema-example}. Den senaste fastslagna versionen \textit{(Draft 7)} av ramverket bygger på tre dokument: \textit{Core}, \textit{Validation} samt \textit{Hyper-Schema}. \cite{A.Wright,Andrews2018,Andrews2018a}

\begin{figure}
	\begin{minted}[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{json}
{
	"type": "object",
	"required": ["firstName", "age"],
	"properties": {
		"firstName": { "type": "string" },
		"lastName": { "type": "string" },
		"age": { "type": "integer" },
		"human": { "type": "boolean" }
	}
}
	\end{minted}
	\vspace{-1.7em}
	\caption{Exempel på simpelt JSON Schema}
	\label{fig:json-schema-example}
\end{figure}

\subsection{JSON Schema Core}
JSON Schema Core täcker grunderna för JSON Schema. Dokumentet fastställer exempelvis mediatypen som borde användas för att skicka JSON Scheman över HTTP, förhållandet mellan flera JSON Scheman, samt hur heltal borde behandlas. Att JSON Scheman själva är JSON-dokument bestäms också. Dokumentet fastställer också att validering och annotering av JSON-värden ska ske enligt dokumentet draft-handrews-json-schema-validation-01 \textit{(Validation)}, samt att draft-handrews-json-schema-hyperschema-01 \textit{(Hyper-Schema)} behandlar reglerna kring att beskriva hypertextstrukturen hos JSON-dokument. \cite{A.Wright}

\subsection{JSON Schema Validation}
JSON Schema Validation beskriver tre saker: hur man beskriver ett JSON-dokument, hur man ger tips åt användargränsnitt för att jobba med JSON-dokument samt hur man kan beskriva påståenden om ett dokuments validitet. Förenklat beskriver det här dokumentet strukturen hos ett JSON Schema, med beskrivningar av nästan alla nyckelorden. Utöver att beskriva hur JSON-dokument ska valideras, presenteras annoteringsnyckelord som \mintinline{json}{"title"} och \mintinline{json}{"description"}, där \mintinline{json}{"title"} är en kort förklaring för JSON värdet den validerar, och \mintinline{json}{"description"} är en längre förklaring. \cite{Andrews2018}

\subsection{JSON Schema Hyper-Schema}
JSON Schema utvecklas till stor del för användandet av JSON Scheman i webbtjänster. Därför beskriver det tredje dokumentet, JSON Schema Hyper-Schema, hur resurser kan manipuleras och interageras med över hypermediamiljöer som HTTP. JSON Schema Validation skulle kunna beskriva hur ett API anrop ska hanteras och vad som förväntas från förfrågningar och svar på dem. JSON Schema Hyper-Schema kan då användas för att beskriva ett helt API och hur de olika anropen och resurserna är relaterade till varandra. \cite{Andrews2018a}

\subsection{Kontroversiella flyttal i JSON Schema}
\label{sec:teori:schema:float}

JSON Schema stöder två nyckelord för siffror: \textit{number}, och \textit{integer}, vilket motsvarar siffror respektive heltal \cite{Andrews}. Nyckelordet \textit{number} betyder inte nödvändigtvis flyttal då JSON och JavaScript inte skiljer på heltal och flyttal, vilket en betydligt stor andel programmeringsspråk gör som Python, Ruby, C, C++, C\#, Java, Delphi med många fler \cite{Embarcadero,Oracle,Microsofta,GNU,GNUa,Britt,Britta,PythonSoftwareFoundation2018,ECMA2013,EcmaInternational2017}. JSON Schema definerar ett heltal som alla siffror med en bråkdel som är lika med noll \cite{Andrews}. Det skulle betyda att både talet 1 och 1.0 skulle tolkas som ett heltal. Många JSON parsers i många språk tolkar 1.0 som ett flyttal vilket gör det svårt att kontrollera om en siffra är ett heltal. Flera implementationer av JSON Schema parsers som exempelvis Python-baserade jsonschema tolkar 1.0 som ett flyttal, trots att JSON Schema specificerar motsatsen \cite{SpaceTelescopeScienceInstitute2016}.

Det finns andra oklarheter kring flyttal, som att det är svårt att validera om ett flyttal är en multipel av ett annat tal, då få språk erbjuder exakt nogranhet för flyttal \cite{Cederqvist2017}. Vissa föreslår att flyttal borde hanteras som textsträngar med nyckelordet \textit{format}, men då krävs en större bredd av valideringstermer för att erbjuda samma funktionalitet som det redan finns till datatyper av typen \textit{number} \cite{Poberezkin,Faassen}.

\section{Användningsområden för JSON Schema}
\label{sec:teori:schema-användningsområden}
Användningsområden för JSON Scheman är bland annat:

\begin{enumerate}
	\item Validering av data.
	\item Annotering av data.
	\item Beskrivning av REST APIer.
	\item Automatisk generering av kompatibel kod, för att hantera JSON värden beskrivna med JSON Schema.
	\item Automatisk generering av API-dokumentation.
	\item Automatisk generering av användargränsnitt.
\end{enumerate}

\noindent
Att använda JSON Schema för användningsområdena 1-3 är trivialt. Det går att utveckla program som kan hantera alla oändligt möjliga permutationer av JSON Schema. Det som däremot inte är trivialt är hur användningsområdena 4-6 skulle kunna generaliseras så pass mycket att ett program eller algoritm skulle kunna hantera vilket giltigt JSON Schema som helst. Användningsområde fyra och fem omfattas inte av den här rapporten, och varför användningsområde sex inte är trivialt diskuteras mer i resultatet.
% Byt ut resultatet mot rätt kapitel

The Json Schema organisation listar kända implementationer på sin hemsida, och har delat upp dem i följande kategorier \cite{TheJSONSchemaorganisation}:
\begin{itemize}
	\item Validators
	\item Hyper-Schema
	\item Schema generation
	\item Data parsing
	\item UI generation
	\item Editors
	\item Compatibility
	\item Documentation generation
\end{itemize}
\noindent
Arbetet kommer behöva implementera tre av de listade implementationerna: Schema generation, Data parsing samt UI generation, vilket diskuteras i kapitel \ref{sec:teori:schema-användningsområden:generering}, \ref{sec:teori:schema-användningsområden:parsning} samt \ref{sec:teori:schema-användningsområden:ui-generering}.

\subsection{Generering av scheman}
\label{sec:teori:schema-användningsområden:generering}
Schemagenerering som kategori består av tolv implementationer där det går att ytterligare dela upp implementationerna i tre kategorier. Det finns implementationer som utgår från JSON data, och genererar ett JSON Schema för att beskriva datan. Det kan användas om det går att anta att all användning av JSON Schemat kommer att användas på data med exakt likadan struktur. Den andra kategorin av implementationer är implementationer som genererar JSON Scheman utifrån kända datatyper i ett statiskt typat språk. Den tredje kategorin av implementation är implementationer som erbjuder en annan metod att beskriva datan, för att sedan översätta det till ett JSON Schema. \cite{TheJSONSchemaorganisation}

\subsubsection{Implementationerna som genererar JSON Scheman från JSON data:}
\begin{itemize}
	\item Schema Guru \textit{(Scala)} \cite{Snowplow}
	\item JSON Schema Generator \textit{(Visual Studio)} \cite{MadsKristensen}
	\item json-schema-generator \textit{(JavaScript / JSON)} \cite{Romanovich}
\end{itemize}

\subsubsection{Implementationerna som genererar JSON Scheman från statiska datatyper inbyggda i språket:}
\begin{itemize}
	\item Json.NET Schema \textit{.NET} \cite{Newtonsoft}
	\item NJsonSchema for .NET \textit{.NET} \cite{Suter}
	\item typescript-json-schema \textit{(TypeScript)} \cite{El-Dardiry}
	\item Typson \textit{(TypeScript)} \cite{Bovet}
\end{itemize}

\subsubsection{Implementationerna som genererar JSON Scheman från andra liknande beskrivningar:}
\begin{itemize}
	\item Liform \textit{(PHP)} \cite{Limenius}
	\item JSL \textit{(Python)} \cite{Romanovich}
	\item JSONSchema.net \textit{(Online webbverktyg)} \cite{Bovet}
	\item Schema Guru Web UI \textbf{Obs:} Verktyget hittades ej och kommer därför exkluderas från resten av rapporten.
	\item APIAddIn \textit{(Sparx Enterprise Architect)} \cite{Tomlinson}
\end{itemize}

\subsection{Parsning av JSON Scheman}
\label{sec:teori:schema-användningsområden:parsning}
En parser tolkar JSON Scheman och representerar schemat med någon annan datastruktur. Ofta är parsning viktigt för att schemat ska kunna representeras med en datastruktur som programmeringsspråket är kompatibelt med. Vissa implementationer använder ett färdigt JSON Schema och genererar kod som är kompatibelt med att hantera JSON som är formaterad utifrån schemats struktur. Andra implementationer kan dynamiskt hantera vilket schema som helst under exekvering, och dynamiskt skapa parsers för JSON formaterad utifrån schemat. De parsers som listas på The Json Schema organisations hemsida är följande:

\begin{itemize}
	\item DJsonSchema \textit{Delphi} \cite{Schlothauer&WauerGmbH}
	\item jsonCodeGen \textit{Groovy} \cite{Schlothauer&WauerGmbHa}
	\item aeson-schema \textit{Haskell} \cite{Kowalczyk}
	\item AutoParse \textit{Ruby} \cite{Googleb}
	\item json-schema-codegen \textit{Scala} \cite{Tundra}
	\item Argus \textit{Scala} \cite{Fenton}
	\item Bric-à-brac \textit{Swift} \cite{GlimpseI/OInc}
	\item gojsonschema \textit{Golang} \textbf{Obs:} Verktyget saknade information på engelska eller svenska och kommer därför exkluderas från resten av rapporten. \cite{Zhangtao}
	\item jsonschema \textit{Golang} \cite{Qriinc.}
\end{itemize}

\subsection{Tidigare försök av generering av användargränsnitt baserade på JSON Scheman}
\label{sec:teori:schema-användningsområden:ui-generering}
Det finns olika implementationer av att generera ett användargränsnitt utifrån ett JSON Schema. Samtliga kända implementationer är skrivna i språket JavaScript och bemöter därför ingen av svårigheterna med att använda JSON eller JSON Schema med andra språk. Samtliga implementationer är implementationer för att generera hemsidor eller komponenter till hemsidor, vilket skiljer sig mycket mot att generera användargränsnitt åt Windows med Delphi, vilket arbetet gjorde.

Vissa av implementationerna används för att generera ett användargränsnitt för att förklara ett API beskrivet med JSON Schema och andra implementationer används för att generera ett formulär för att manipulera data beskrivet av JSON Schema. Att generera ett formulär för att manipulera data beskrivet av JSON Schema är exakt vad den här rapporten utvärderar. Användargränsnittsgenererarna som listas på The Json Schema organisations hemsida är följande:

\begin{itemize}
	\item Alpaca Forms \cite{GitanaSoftwareInc.}
	\item Angular Schema Form \cite{Textalk}
	\item Angular2 Schema Form \cite{MakinaCorpus}
	\item JSON Editor \cite{JeremyDorn}
	\item JSON Form \cite{Joshfire}
	\item json-forms \cite{Brutusin.org}
	\item JSONForms  \cite{EclipseSource}
	\item Jsonary  \textbf{OBS!}
	\item liform-react \cite{NachoMartin}
	\item Metawidget \cite{Metawidget}
	\item pure-form webcomponent \textbf{Obs not found}
	\item React JSON Schema Form \cite{MozillaServices}
	\item React Schema Form \cite{NetworkNewTechnologiesInc.}
\end{itemize}

%\section{JSON Schema förklarat med BNF}
%
%
%\inputminted[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{bnf}{code/json-schema.bnf}
%\inputminted[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{ebnf}{code/json-schema.ebnf}
%\inputminted[tabsize=2, frame=single, fontsize=\small, framesep=2mm]{ebnf}{code/strSch.ebnf}


%	<statement> ::= <ident> `=' <expr> 
%	\alt `for' <ident> `=' <expr> `to' <expr> `do' <statement> 
%	\alt `{' <stat-list> `}' 
%	\alt <empty> 
%
%	<stat-list> ::= <statement> `;' <stat-list> | <statement> 
%
%	<statement> ::= <ident> `=' <expr> 
%	\alt `for' <ident> `=' <expr> `to' <expr> `do' <statement> 
%	\alt `{' <stat-list> `}' 
%	\alt <empty> 
%	
%	<stat-list> ::= <statement> `;' <stat-list> | <statement> 



%\begin{syntdiag}
%	<ident> ‘(’
%	\begin{rep} \begin{stack} \\
%			<type> \begin{stack} \\ <ident> \end{stack}
%		\end{stack} \\ ‘,’ \end{rep}
%	\begin{stack} \\ ‘...’ \end{stack} ‘)’
%\end{syntdiag}

